<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Strict//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>/home/who/git/nginx-clojure.github.io/.More.md.html</title>


<style type="text/css">

.markdown-body {
    border: 1px solid #CACACA;
    padding: 30px;
    font-size: 14px;
    line-height: 1.6;
}

.markdown-body h2 {
    border-bottom: 1px solid #CCCCCC;
}

.markdown-body code {
    white-space: nowrap;
}

.markdown-body code, .markdown-body tt {
    background-color: #F8F8F8;
    border: 1px solid #EAEAEA;
    border-radius: 3px 3px 3px 3px;
    margin: 0 2px;
    padding: 0 5px;
}

.markdown-body .highlight pre, .markdown-body pre {
    background-color: #F8F8F8;
    border: 1px solid #CCCCCC;
    border-radius: 3px 3px 3px 3px;
    font-size: 13px;
    line-height: 19px;
    overflow: auto;
    padding: 6px 10px;
}

.markdown-body img {
    border: 0 none;
}

pre, code, tt {
    font-family: Consolas,"Liberation Mono",Courier,monospace;
    font-size: 12px;
}

</style>


<script type="text/javascript">

function getDocumentScrollTop() 
{
   var res = document.body.scrollTop || document.documentElement.scrollTop || window.pageYOffset || 0;
   // alert(res);
   return res;
}

function setDocumentScrollTop(ypos) 
{
	window.scrollTo(0, ypos);
}

</script>


</head>
<body class="markdown-body">
<h1> <a name="user-content-3-more-about-nginx-clojure" class="anchor" href="..md.html#3-more-about-nginx-clojure" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. More about Nginx-Clojure</h1> 
<h2> <a name="user-content-31-handle-multiple-coroutine-based-sockets-parallel" class="anchor" href="..md.html#31-handle-multiple-coroutine-based-sockets-parallel" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 Handle Multiple Coroutine Based Sockets Parallel</h2> 
<p>Sometimes we need invoke serveral remote services before completing the ring response. For better performance we need a way to handle multiple sockets parallel in sub coroutines.</p> 
<p>e.g. fetch two page parallel by clj-http</p> 
<div class="highlight highlight-clojure">
 <pre>   <span class="p">(</span><span class="k">let </span><span class="p">[[</span><span class="nv">r1</span>, <span class="nv">r2</span><span class="p">]</span> 
                <span class="p">(</span><span class="nf">co-pvalues</span> <span class="p">(</span><span class="nf">client/get</span> <span class="s">&quot;http://service1-url&quot;</span><span class="p">)</span> 
                            <span class="p">(</span><span class="nf">client/get</span> <span class="s">&quot;http://service2-url&quot;</span><span class="p">))]</span>
    <span class="c1">;println bodies of two remote response</span>
    <span class="p">(</span><span class="nb">println </span><span class="p">(</span><span class="nb">str </span><span class="p">(</span><span class="ss">:body</span> <span class="nv">r1</span><span class="p">)</span> <span class="s">&quot;====\n&quot;</span> <span class="p">(</span><span class="ss">:body</span> <span class="nv">r2</span><span class="p">)</span> <span class="p">))</span>
</pre>
</div> 
<p>Here <code>co-pvalues</code> is also non-blocking and coroutine based. In fact it will create two sub coroutines to handle two sockets.</p> 
<p>For Java/Groovy, we can use <code>NginxClojureRT.coBatchCall</code> to do the same thing. Here 's a simple example for Groovy.</p> 
<div class="highlight highlight-groovy">
 <pre>     <span class="kt">def</span> <span class="o">(</span><span class="n">r1</span><span class="o">,</span> <span class="n">r2</span><span class="o">)</span> <span class="o">=</span> <span class="n">NginxClojureRT</span><span class="o">.</span><span class="na">coBatchCall</span><span class="o">(</span> 
       <span class="o">{</span><span class="s2">&quot;http://mirror.bit.edu.cn/apache/httpcomponents/httpclient/&quot;</span><span class="o">.</span><span class="na">toURL</span><span class="o">().</span><span class="na">text</span><span class="o">},</span>
       <span class="o">{</span><span class="s2">&quot;http://mirror.bit.edu.cn/apache/httpcomponents/httpcore/&quot;</span><span class="o">.</span><span class="na">toURL</span><span class="o">().</span><span class="na">text</span><span class="o">})</span>
     <span class="k">return</span> <span class="o">[</span><span class="mi">200</span><span class="o">,</span> <span class="o">[</span><span class="s2">&quot;Content-Type&quot;</span><span class="o">:</span><span class="s2">&quot;text/html&quot;</span><span class="o">],</span> <span class="n">r1</span> <span class="o">+</span> <span class="n">r2</span><span class="o">];</span>

</pre>
</div> 
<h2> <a name="user-content-32-shared-map-among-nginx-workers" class="anchor" href="..md.html#32-shared-map-among-nginx-workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 Shared Map among Nginx Workers</h2> 
<p>Generally use redis or memorycached is the better choice to implement a shared map among Nginx workers. We can do some initialization of the shared map by following the guide of <a href="..md.html#22-initialization-handler-for-nginx-worker">2.2 Initialization Handler for nginx worker</a>. If you like shared map managed in nginx processes better than redis or memcached, you can choose <a href="https://github.com/OpenHFT/Chronicle-Map">SharedHashMap/Chronicle-Map</a> which is fast and based on Memory Mapped File so that it can store<br /> large amout of records and won't need too much java heap memory.</p> 
<h2> <a name="user-content-33-user-defined-http-method" class="anchor" href="..md.html#33-user-defined-http-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 User Defined Http Method</h2> 
<p>Some web services need user defined http request method to define special operations beyond standard http request methods. </p> 
<p>e.g. We use <code>MYUPLOAD</code> to upload a file and overwrite the one if it exists. The <code>curl</code> command maybe is </p> 
<div class="highlight highlight-bash">
 <pre>curl   -v  -X MYUPLOAD  --upload-file post-test-data <span class="se">\</span>
<span class="s2">&quot;http://localhost:8080/myservice&quot;</span> 
</pre>
</div> 
<p>In the nginx.conf, we can use <code>always_read_body on;</code> to force nginx to read http body.</p> 
<div class="highlight highlight-nginx">
 <pre>
<span class="k">location</span> <span class="s">/myservice</span> <span class="p">{</span>
         <span class="kn">handler_type</span> <span class="s">'clojure'</span><span class="p">;</span>
         <span class="kn">always_read_body</span> <span class="no">on</span><span class="p">;</span>
         <span class="kn">handler_code</span> <span class="s">'....'</span><span class="p">;</span>
<span class="p">}</span>

</pre>
</div> 
<h2> <a name="user-content-34-long-polling--server-sent-events-sse" class="anchor" href="..md.html#34-long-polling--server-sent-events-sse" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.4 Long Polling &amp; Server Sent Events (SSE)</h2> 
<p>Since v0.2.5, nginx-clojure provides union form of <a href="https://github.com/nginx-clojure/nginx-clojure/issues/41">hijack API</a> to do with Long Polling &amp; Server Sent Events (SSE).</p> 
<h3> <a name="user-content-hijack-the-request" class="anchor" href="..md.html#hijack-the-request" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hijack the Request</h3> 
<p>We can hijack the request to get a http server channel to sent some messages later. After hijacking the return result from ring handler will be ignore so we can finely control when &amp; what to be sent to the client.</p> 
<p>For Clojure</p> 
<div class="highlight highlight-clojure">
 <pre>
<span class="p">(</span><span class="k">fn </span><span class="nv">my-handler</span><span class="p">[</span><span class="nv">req</span><span class="p">]</span>
         <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">hijack!</span> <span class="nv">req</span> <span class="nv">true</span><span class="p">)]</span>
          <span class="c1">;;; save channel ch to use it later     </span>
<span class="p">))</span>
</pre>
</div> 
<p>The complete <code>hijack!</code> description is below </p> 
<div class="highlight highlight-clojure">
 <pre>
<span class="p">(</span><span class="kd">defn </span><span class="nv">hijack!</span> 
  <span class="s">&quot;Hijack a nginx request and return a server channel.</span>
<span class="s">   After being hijacked, the ring handler's result will be ignored.</span>
<span class="s">   If ignore-nginx-filter? is true all data output to channel won't be filtered</span>
<span class="s">   by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.</span>
<span class="s">   We can use this function to implement long polling / Server Sent Events (SSE) easily.&quot;</span>
  <span class="p">[</span><span class="o">^</span><span class="nv">NginxRequest</span> <span class="nv">req</span> <span class="nv">ignore-nginx-filter?</span><span class="p">])</span>
</pre>
</div> 
<p>For Java</p> 
<div class="highlight highlight-java">
 <pre>
    <span class="kd">public</span>  <span class="kd">class</span> <span class="nc">MyHandler</span> <span class="kd">implements</span> <span class="n">NginxJavaRingHandler</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">NginxJavaRequest</span> <span class="n">r</span> <span class="o">=</span> <span class="o">((</span><span class="n">NginxJavaRequest</span><span class="o">)</span><span class="n">request</span><span class="o">);</span>
            <span class="n">NginxHttpServerChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">handler</span><span class="o">().</span><span class="na">hijack</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>           
            <span class="c1">//save channel ch to use it later    </span>
            <span class="c1">//nginx-clojure will ignore this return because we have hijacked the request.</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

</pre>
</div> 
<h3> <a name="user-content-send-a-complete-response-for-long-polling" class="anchor" href="..md.html#send-a-complete-response-for-long-polling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Send a Complete Response for Long Polling</h3> 
<p>When some event happen which let a complete response must be sent to the Long Polling request client we can use <code>send-response!</code>(Clojure) or sendResponse (Java/Groovy) to send a complete response. This action is non-blocking and after completion the channel will be closed automatically.</p> 
<p>For Clojure</p> 
<div class="highlight highlight-clojure">
 <pre>
<span class="p">(</span><span class="nf">send-response!</span> <span class="nv">ch</span> <span class="p">{</span><span class="ss">:status</span> <span class="mi">200</span>, <span class="ss">:headers</span> <span class="p">{</span><span class="s">&quot;content-type&quot;</span> <span class="s">&quot;text/plain&quot;</span><span class="p">}</span>, <span class="ss">:body</span> <span class="nv">data</span><span class="p">}</span>
</pre>
</div> 
<p>For Java</p> 
<div class="highlight highlight-Java">
 <pre>
<span class="n">channel</span><span class="o">.</span><span class="na">sendResponse</span><span class="o">(</span><span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">NGX_HTTP_OK</span><span class="o">,</span>
                <span class="n">ArrayMap</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&quot;content-type&quot;</span><span class="o">,</span> <span class="s">&quot;text/json&quot;</span><span class="o">),</span>
                <span class="n">message</span><span class="o">});</span>
</pre>
</div> 
<h3> <a name="user-content-send-messages-for-server-sent-events-sse" class="anchor" href="..md.html#send-messages-for-server-sent-events-sse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Send Messages for Server Sent Events (SSE)</h3> 
<p>First we can use <code>send-headers!</code>(Clojure) or <code>sendHeaders</code> (Java/Groovy) to send a SSE header. Then we can use <code>send!</code> (Clojure) or <code>send</code> (Java/Groovy) to send later messages. The last two parameters of send function is used to flush message or close channel after sending current message.</p> 
<p>For Clojure:</p> 
<div class="highlight highlight-Clojure">
 <pre>
 <span class="c1">;;; send header and retry hint of SSE</span>
 <span class="p">(</span><span class="nf">send-header!</span> <span class="nv">ch</span> <span class="mi">200</span> <span class="p">{</span><span class="s">&quot;Content-Type&quot;</span>, <span class="s">&quot;text/event-stream&quot;</span><span class="p">}</span> <span class="nv">false</span> <span class="nv">false</span><span class="p">)</span>
 <span class="p">(</span><span class="nf">send!</span> <span class="nv">ch</span> <span class="s">&quot;retry: 4500\r\n&quot;</span> <span class="nv">true</span> <span class="nv">false</span><span class="p">)</span>

 <span class="c1">;;; send the message and do flush </span>
 <span class="p">(</span><span class="nf">send!</span> <span class="nv">ch</span> <span class="s">&quot;data: Are you ok?\r\n&quot;</span> <span class="nv">true</span> <span class="nv">false</span><span class="p">)</span>

 <span class="c1">;;; send the last message, identical to (send! ch data true false) (close! ch)</span>
 <span class="p">(</span><span class="nf">send!</span> <span class="nv">ch</span> <span class="s">&quot;data: Bye, bye.\r\n&quot;</span> <span class="nv">true</span> <span class="nv">true</span><span class="p">)</span>

</pre>
</div> 
<p>For Java:</p> 
<div class="highlight highlight-Java">
 <pre>
<span class="c1">//send header and retry hint of SSE</span>
<span class="n">channel</span><span class="o">.</span><span class="na">sendHeader</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="n">ArrayMap</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&quot;Content-Type&quot;</span><span class="o">,</span> <span class="s">&quot;text/event-stream&quot;</span><span class="o">).</span><span class="na">entrySet</span><span class="o">(),</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
<span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;retry: 4500\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>

<span class="c1">//send the message and do flush </span>
<span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;data: Are you ok?\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">)</span>

<span class="c1">//send the last message, identical to channel.send(data true false); channel.close();</span>
<span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;data: Bye, bye.\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">)</span>
</pre>
</div> 
<h3> <a name="user-content-listener-about-the-closed-event-of-channel" class="anchor" href="..md.html#listener-about-the-closed-event-of-channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Listener about the Closed Event of Channel</h3> 
<p>A closed event will happen immediately when channel is closed by either of these three cases:</p> 
<ul> 
 <li>channel close function/method is invoked on this channel, e.g. (close! ch)</li> 
 <li>inner unrecoverable error happens with this channel, e.g. not enough memory to read/write</li> 
 <li>remote client connection is closed or broken.</li> 
</ul>
<p>For Clojure</p> 
<div class="highlight highlight-clojure">
 <pre>
<span class="p">(</span><span class="nf">on-close!</span> <span class="nv">ch</span> <span class="p">{</span><span class="ss">:ch</span> <span class="nv">ch</span> <span class="ss">:desc</span> <span class="s">&quot;this is a event attachement&quot;</span><span class="p">}</span>
 <span class="p">(</span><span class="nf">fn</span><span class="p">[</span><span class="nv">att</span><span class="p">]</span> <span class="p">(</span><span class="nf">info</span> <span class="s">&quot;closed channel from request :&quot;</span> <span class="p">(</span><span class="nf">.request</span> <span class="p">(</span><span class="ss">:ch</span> <span class="nv">att</span><span class="p">)))))</span>
</pre>
</div> 
<p>For Java</p> 
<div class="highlight highlight-java">
 <pre>
<span class="n">channel</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="n">channel</span><span class="o">,</span> <span class="k">new</span> <span class="n">ChannelListener</span><span class="o">&lt;</span><span class="n">NginxHttpServerChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">NginxHttpServerChannel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Init</span><span class="o">.</span><span class="na">serverSentEventSubscribers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                    <span class="n">info</span><span class="o">(</span><span class="s">&quot;closed &quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">request</span><span class="o">().</span><span class="na">nativeRequest</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onConnect</span><span class="o">(</span><span class="kt">long</span> <span class="n">status</span><span class="o">,</span> <span class="n">NginxHttpServerChannel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>
            <span class="o">});</span>
</pre>
</div> 
<h2> <a name="user-content-35-subpub--broadcast-event" class="anchor" href="..md.html#35-subpub--broadcast-event" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.5 Sub/Pub &amp; broadcast Event</h2> 
<p>Suppose our Nginx instance has 3 workers (worker process not jvm_workers which is just thread number of thread pool in jvm). Now we want to provide sub/pub service. e.g.</p> 
<ol> 
 <li>Client A connected to nginx worker A and subscribed to uri <code>/mychannel/sub</code> </li> 
 <li>Client B connected to nginx worker B and subscribed to uri <code>/mychannel/sub</code> </li> 
 <li>Client C connected to nginx worker C and publish a message to uri <code>/mychannel/pub</code> </li> 
</ol>
<p>So the service at endpoint of <code>/mychannel/pub</code> must broadcast pub event to Client A and Client B. Although for large-scale application we can use sub/pub service from Redis on nginx-clojure , for small-scale or medium-scale application this feature will make the dev life easier.</p> 
<p>This feature supports two kinds of events to broadcast, simple events and complex events.</p> 
<ol> 
 <li>A simple event only has a event id which is a long integer and must be less than 0x0100000000000000L, it hasn't any body or its body is stored in some external stores, e.g. SharedHashMap, Memcached, Redis etc.</li> 
 <li>A complex event has a message with a length limitation <code>PIPE_BUF - 8</code>, generally on Linux/Windows is 4088, on MacosX is 504.</li> 
</ol>
<p>Here's a simple Sub/Pub Service based on API of broadcast &amp; Server Sent Events. More details can be found from issue #38 and its comments <a href="https://github.com/nginx-clojure/nginx-clojure/issues/38">nginx-clojure broadcast API</a></p> 
<p>For Clojure</p> 
<div class="highlight highlight-clojure">
 <pre>
<span class="p">(</span><span class="k">def </span><span class="nv">sse-subscribers</span> <span class="p">(</span><span class="nf">atom</span> <span class="p">{}))</span>
<span class="p">(</span><span class="k">def </span><span class="nv">sse-event-tag</span> <span class="p">(</span><span class="nb">int </span><span class="p">(</span><span class="nb">+ </span><span class="mi">0</span><span class="nv">x80</span> <span class="mi">10</span><span class="p">)))</span>

<span class="p">(</span><span class="k">def </span><span class="nv">init-broadcast-event-listener</span>
  <span class="p">(</span><span class="nf">delay</span> 
    <span class="p">(</span><span class="nf">on-broadcast-event-decode!</span>
      <span class="c1">;;tester</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[{</span><span class="nv">tag</span> <span class="ss">:tag</span><span class="p">}]</span> 
        <span class="p">(</span><span class="nb">= </span><span class="nv">tag</span> <span class="nv">sse-event-tag</span><span class="p">))</span>
      <span class="c1">;;decoder</span>
      <span class="p">(</span><span class="k">fn </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">tag</span> <span class="nv">data</span> <span class="nv">offset</span> <span class="nv">length</span><span class="p">]</span> <span class="ss">:as</span> <span class="nv">e</span><span class="p">}]</span>
        <span class="p">(</span><span class="nb">assoc </span><span class="nv">e</span> <span class="ss">:data</span> <span class="p">(</span><span class="nf">String.</span> <span class="nv">data</span> <span class="nv">offset</span> <span class="nv">length</span> <span class="s">&quot;utf-8&quot;</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">on-broadcast!</span> 
      <span class="p">(</span><span class="k">fn </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">tag</span> <span class="nv">data</span><span class="p">]}]</span>
        <span class="p">(</span><span class="nf">log</span> <span class="s">&quot;#%s ring_handlers_for_test: onbroadcast {%d %s} %s&quot;</span> <span class="nv">process-id</span> <span class="nv">tag</span> <span class="nv">data</span> <span class="o">@</span><span class="nv">sse-subscribers</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">condp</span> <span class="nb">= </span><span class="nv">tag</span>
          <span class="nv">sse-event-tag</span> 
            <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nb">keys </span><span class="o">@</span><span class="nv">sse-subscribers</span><span class="p">)]</span>
              <span class="p">(</span><span class="nf">send!</span> <span class="nv">ch</span> <span class="p">(</span><span class="nb">str </span><span class="s">&quot;data: &quot;</span> <span class="nv">data</span> <span class="s">&quot;\r\n\r\n&quot;</span><span class="p">)</span> <span class="nv">true</span> <span class="p">(</span><span class="nb">= </span><span class="s">&quot;finish!&quot;</span> <span class="nv">data</span><span class="p">)</span> <span class="p">))</span>
            <span class="nv">nil</span><span class="p">)))))</span>


  <span class="c1">;;server sent events publisher</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">sse-publisher</span> <span class="p">[</span><span class="nv">req</span><span class="p">]</span>
         <span class="p">(</span><span class="nf">broadcast!</span> <span class="p">{</span><span class="ss">:tag</span> <span class="nv">sse-event-tag</span>, <span class="ss">:data</span> <span class="p">(</span><span class="ss">:query-string</span> <span class="nv">req</span><span class="p">)})</span>
         <span class="p">{</span><span class="ss">:body</span> <span class="s">&quot;OK&quot;</span><span class="p">})</span>

  <span class="c1">;;server sent events subscriber</span>
  <span class="p">(</span><span class="kd">defn </span><span class="nv">sse-sub</span> <span class="p">[</span><span class="o">^</span><span class="nv">NginxRequest</span> <span class="nv">req</span><span class="p">]</span>
         <span class="o">@</span><span class="nv">init-broadcast-event-listener</span>
         <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">ch</span> <span class="p">(</span><span class="nf">hijack!</span> <span class="nv">req</span> <span class="nv">true</span><span class="p">)]</span>
           <span class="p">(</span><span class="nf">on-close!</span> <span class="nv">ch</span> <span class="nv">ch</span> 
                      <span class="p">(</span><span class="k">fn </span><span class="p">[</span><span class="nv">ch</span><span class="p">]</span> <span class="p">(</span><span class="nf">log</span> <span class="s">&quot;channel closed. id=%d&quot;</span> <span class="p">(</span><span class="nf">.nativeRequest</span> <span class="nv">req</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">log</span> <span class="s">&quot;#%s sse-sub: onclose arg:%s, sse-subscribers=%s&quot;</span> <span class="nv">process-id</span> <span class="nv">ch</span> <span class="p">(</span><span class="nb">pr-str </span><span class="o">@</span><span class="nv">sse-subscribers</span><span class="p">))</span>
                         <span class="p">(</span><span class="nf">swap!</span> <span class="nv">sse-subscribers</span> <span class="nb">dissoc </span><span class="nv">ch</span><span class="p">)))</span>
           <span class="p">(</span><span class="nf">swap!</span> <span class="nv">sse-subscribers</span> <span class="nb">assoc </span><span class="nv">ch</span> <span class="nv">req</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">send-header!</span> <span class="nv">ch</span> <span class="mi">200</span> <span class="p">{</span><span class="s">&quot;Content-Type&quot;</span>, <span class="s">&quot;text/event-stream&quot;</span><span class="p">}</span> <span class="nv">false</span> <span class="nv">false</span><span class="p">)</span>
           <span class="p">(</span><span class="nf">send!</span> <span class="nv">ch</span> <span class="s">&quot;retry: 4500\r\n&quot;</span> <span class="nv">true</span> <span class="nv">false</span><span class="p">)))</span>
</pre>
</div> 
<p>For Java</p> 
<div class="highlight highlight-java">
 <pre>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Init</span> <span class="kd">implements</span> <span class="n">NginxJavaRingHandler</span><span class="o">,</span> <span class="n">Listener</span> <span class="o">{</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">SEVER_SENT_EVENTS</span> <span class="o">=</span> <span class="n">POST_EVENT_TYPE_COMPLEX_EVENT_IDX_START</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>

        <span class="kd">public</span> <span class="kd">static</span> <span class="n">Set</span><span class="o">&lt;</span><span class="n">NginxHttpServerChannel</span><span class="o">&gt;</span> <span class="n">serverSentEventSubscribers</span><span class="o">;</span>

        <span class="kd">public</span> <span class="nf">Init</span><span class="o">()</span> <span class="o">{</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">doInit</span><span class="o">()</span> <span class="o">{</span>
            <span class="n">serverSentEventSubscribers</span> <span class="o">=</span> <span class="n">Collections</span><span class="o">.</span><span class="na">newSetFromMap</span><span class="o">(</span><span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">NginxHttpServerChannel</span><span class="o">,</span> <span class="n">Boolean</span><span class="o">&gt;());</span>
            <span class="n">NginxClojureRT</span><span class="o">.</span><span class="na">getAppEventListenerManager</span><span class="o">().</span><span class="na">addListener</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onEvent</span><span class="o">(</span><span class="n">PostedEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">tag</span> <span class="o">!=</span> <span class="n">LONGPOLL_EVENT</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="o">.</span><span class="na">tag</span> <span class="o">!=</span> <span class="n">SEVER_SENT_EVENTS</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">return</span><span class="o">;</span>
            <span class="o">}</span>
            <span class="n">String</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">String</span><span class="o">((</span><span class="kt">byte</span><span class="o">[])</span><span class="n">event</span><span class="o">.</span><span class="na">data</span><span class="o">,</span> <span class="n">event</span><span class="o">.</span><span class="na">offset</span><span class="o">,</span> <span class="n">event</span><span class="o">.</span><span class="na">length</span><span class="o">,</span> <span class="n">DEFAULT_ENCODING</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">tag</span> <span class="o">==</span> <span class="n">SEVER_SENT_EVENTS</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">for</span> <span class="o">(</span><span class="n">NginxHttpServerChannel</span> <span class="n">channel</span> <span class="o">:</span> <span class="n">serverSentEventSubscribers</span><span class="o">)</span> <span class="o">{</span>
                    <span class="k">if</span> <span class="o">(</span><span class="s">&quot;shutdown!&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">message</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;data: &quot;</span><span class="o">+</span><span class="n">message</span><span class="o">+</span><span class="s">&quot;\r\n\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
                    <span class="o">}</span><span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="s">&quot;shutdownQuite!&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">message</span><span class="o">))</span> <span class="o">{</span>
                        <span class="n">channel</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
                    <span class="o">}</span><span class="k">else</span> <span class="o">{</span>
                        <span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;data: &quot;</span><span class="o">+</span><span class="n">message</span><span class="o">+</span><span class="s">&quot;\r\n\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
                    <span class="o">}</span>
                <span class="o">}</span>
            <span class="o">}</span>

        <span class="o">}</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SSESub</span> <span class="kd">implements</span> <span class="n">NginxJavaRingHandler</span> <span class="o">{</span>

        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">SSESub</span><span class="o">()</span> <span class="o">{</span>
                <span class="k">new</span> <span class="nf">Init</span><span class="o">().</span><span class="na">doInit</span><span class="o">();</span>
        <span class="o">}</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">NginxJavaRequest</span> <span class="n">r</span> <span class="o">=</span> <span class="o">(</span><span class="n">NginxJavaRequest</span><span class="o">)</span> <span class="n">request</span><span class="o">;</span>
            <span class="n">NginxHandler</span> <span class="n">handler</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="na">handler</span><span class="o">();</span>
            <span class="n">NginxHttpServerChannel</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">handler</span><span class="o">.</span><span class="na">hijack</span><span class="o">(</span><span class="n">r</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
            <span class="n">channel</span><span class="o">.</span><span class="na">addListener</span><span class="o">(</span><span class="n">channel</span><span class="o">,</span> <span class="k">new</span> <span class="n">ChannelListener</span><span class="o">&lt;</span><span class="n">NginxHttpServerChannel</span><span class="o">&gt;()</span> <span class="o">{</span>
                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onClose</span><span class="o">(</span><span class="n">NginxHttpServerChannel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
                    <span class="n">Init</span><span class="o">.</span><span class="na">serverSentEventSubscribers</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">data</span><span class="o">);</span>
                    <span class="n">NginxClojureRT</span><span class="o">.</span><span class="na">getLog</span><span class="o">().</span><span class="na">info</span><span class="o">(</span><span class="s">&quot;closing....&quot;</span> <span class="o">+</span> <span class="n">data</span><span class="o">.</span><span class="na">request</span><span class="o">().</span><span class="na">nativeRequest</span><span class="o">());</span>
                <span class="o">}</span>

                <span class="nd">@Override</span>
                <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onConnect</span><span class="o">(</span><span class="kt">long</span> <span class="n">status</span><span class="o">,</span> <span class="n">NginxHttpServerChannel</span> <span class="n">data</span><span class="o">)</span> <span class="o">{</span>
                <span class="o">}</span>
            <span class="o">});</span>
            <span class="n">Init</span><span class="o">.</span><span class="na">serverSentEventSubscribers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">channel</span><span class="o">);</span>
            <span class="n">channel</span><span class="o">.</span><span class="na">sendHeader</span><span class="o">(</span><span class="mi">200</span><span class="o">,</span> <span class="n">ArrayMap</span><span class="o">.</span><span class="na">create</span><span class="o">(</span><span class="s">&quot;Content-Type&quot;</span><span class="o">,</span> <span class="s">&quot;text/event-stream&quot;</span><span class="o">).</span><span class="na">entrySet</span><span class="o">(),</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="n">channel</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="s">&quot;retry: 4500\r\n&quot;</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="kc">false</span><span class="o">);</span>
            <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">SSEPub</span> <span class="kd">implements</span> <span class="n">NginxJavaRingHandler</span> <span class="o">{</span>

        <span class="nd">@Override</span>
        <span class="kd">public</span> <span class="n">Object</span><span class="o">[]</span> <span class="nf">invoke</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
            <span class="cm">/*</span>
<span class="cm">             * Or use NginxClojureRT.broadcastEvent(Init.SEVER_SENT_EVENTS, request.get(QUERY_STRING).toString());</span>
<span class="cm">             */</span>
            <span class="n">PostedEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">PostedEvent</span><span class="o">(</span><span class="n">Init</span><span class="o">.</span><span class="na">SEVER_SENT_EVENTS</span><span class="o">,</span> <span class="n">request</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">QUERY_STRING</span><span class="o">).</span><span class="na">toString</span><span class="o">());</span>
            <span class="n">NginxClojureRT</span><span class="o">.</span><span class="na">getAppEventListenerManager</span><span class="o">().</span><span class="na">broadcast</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]</span> <span class="o">{</span> <span class="n">NGX_HTTP_OK</span><span class="o">,</span> <span class="kc">null</span><span class="o">,</span> <span class="s">&quot;OK&quot;</span> <span class="o">};</span>
        <span class="o">}</span>

    <span class="o">}</span>

</pre>
</div> 
<h2> <a name="user-content-36-asynchronous-channel" class="anchor" href="..md.html#36-asynchronous-channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.6 Asynchronous Channel</h2> 
<p>Asynchronous Channel is wrapper of Asynchronous Socket for more easier usage. So far Asynchronous Channel <em>cann't</em> work with thread pool mode. The Asynchronous Channel API is a little like Java 7 NIO.2 Asynchronous Channel and more details can be found from issue #37 and it comments <a href="https://github.com/nginx-clojure/nginx-clojure/issues/37">Asynchronous Channel API</a>.</p> 
<p>Here 's an example which is to get content from mirror.bit.edu.cn:8080 and sent it to client. </p> 
<ul> 
 <li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/clojure/nginx/clojure/asyn_channel_handlers_for_test.clj">Clojure Example</a></li> 
 <li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/java/nginx/clojure/net/SimpleHandler4TestNginxClojureAsynChannel.java">Java Example</a></li> 
</ul>
</body>
</html>
